# 互斥量目前的实现问题

## 问题一

互斥量 flag 使用 FIFO 模式。

A（优先级20）已经获得互斥锁
此时 B（优先级 10） 尝试获取互斥锁
此时 C (优先级 1) 尝试获取互斥锁

当此时 A 的优先级被暂时提高到 1，等运行完毕后 A 线程会把锁交给线程 B，使得线程 B 开始运行，但是此时再也不会将 B 的优先级提升到 C 的优先级了，此时 C 就必须等到 B 完全运行退出，相当于再次出现了优先级反转问题。

这里问题的关键是，提升优先级的动作只会发生一次。

## 问题二

A（优先级20）已经获得互斥锁
此时 B（优先级 1） 尝试获取互斥锁

如果 B 因为超时退出，而 A 的优先级任然被短暂提高，造成 A 线程意外得到了运行。

## 应当处理优先级提权的场景

1. 任务尝试获取互斥锁时，应当查看当前获取该锁的任务的优先级是否比自己低
2. 任务获取到互斥锁时，应当查看阻塞在当前互斥量列表中的所有任务，看他们的优先级是否比自己高，如果有任务比自己的优先级高，则将自己的优先级提高到最高任务的优先级（在 prio 模式下是不存在这个问题的，因为获取互斥锁的任务一定是当前列表中最高优先级的任务）
3. 高优先级的阻塞时间不是 forever 时，应当在退出等待队列时，降低先前被提权的任务的优先级