# ARMv8 架构编程探索

随着开发工作逐渐迁移到 ARMv8 的 64 位平台，因此有必要尽快熟悉 ARMv8 架构。ARMv8 与先前较为熟悉的 ARMv7 机构有较大的变化，其中非常重要的一点就是支持了 A64 指令集，大大提升了处理器的性能。从目前的的了解来看，基本上 ARMv8 与上代架构的差别是非常大的。除了 A64 指令集之外，还有许多地方都有了较大变化，下面列出几个目前比较关注的点：

- 执行状态与异常级别（异常级别为 EL0 - EL3）
- ARMv8 寄存器组（和先前完全不同的 64 位寄存器）
- A64 指令集（新的 64 位指令集）
- 内存管理（毕竟地址空间变成 64 位了）
- 安全系统（例如普通世界和安全世界的切换）

本篇就依据上面的关键点对 ARMv8 架构进行一番探索。

## ARMv8-A 架构基础

![image-20210423144454062](figures/image-20210423144454062.png)

从上图可以看到，ARMv8 架构兼容了 ARMv7 架构的关键特性，例如支持 A32 和 T32 指令集，单精度浮点操作以及基于单精度浮点的 SIMD 指令。 ARMv7 为什么不支持双精度浮点的 SIMD 指令呢？也许是可用的浮点寄存器不够吧，AArch64 使用了 `32*128-bit` 的浮点寄存器，比 ARMv7 要多了一倍。

下图展示了后续要使用的 `Cortex-A53` 与 `Cortex-A57` 处理器属性：

![image-20210423145757846](figures/image-20210423145757846.png)

可用看出，无论是 A53 还是 A57 的性能都远远超过先前的处理器性能，甚至 A57 架构还配备了专用的 GPU。

## 执行状态与异常级别

在 ARMv8 架构中定义了两种执行状态，AArch64 以及 AArch32。这两种执行状态分别用于描述执行使用 64 位宽的通用寄存器或者使用 32 位宽的通用寄存器。然而在 ARMv8 AArch32 中保留了 ARMv7 中定义的特权级，而在 AArch64 中，特权级通过异常等级被定义。因此执行在异常等级 `ELn` 对应于执行在特权等级 `PLn`。

在 AArch64 中，处理器模式在不同的异常等级间切换，就像指在 ARMv7（AArch32） 中当异常被处理时，处理器切换到相应的异常等级来处理异常。下图展示了两种架构在异常处理时的映射关系：

![image-20210423151347275](figures/image-20210423151347275.png)

可以看出先前在 ARMv7 时有各种异常模式，而在 ARMv8 中，这些模式统统都属于 EL1 级别，处理的时候先进入 EL1 的处理函数，然后再通过寄存器信息判断现在发生了哪种异常，然后执行对应的处理函数。

## ARMv8 寄存器组

AArch64 执行状态在所有的异常级别下提供了 31 个 64 位通用寄存器，每一个寄存器有 64 位宽，从 X0-X30。

下图展示了 AArch64 的 通用寄存器组与特殊寄存器：

### 通用寄存器组

![image-20210423152018377](figures/image-20210423152018377.png)

### 特殊功能寄存器组

![image-20210423152111287](figures/image-20210423152111287.png)

可以看出 AArch64 与先前的寄存器组有了非常大的变化，不仅通用寄存器组的宽度和个数变多了，特殊寄存器组也非常不同。特殊寄存器组最大的变化是，先前在 ARMv7 下各种不同模式下的 BANK 寄存器组都没有了，取而代之的是不同级别异常下的 SP 指针、SPSR 以及异常返回寄存器组。

同时为了兼容先前 ARMv7 下 AArch32 执行状态，支持从 AArch64 到 AArch32 寄存器组的映射，如下图所示：

![image-20210423152918083](figures/image-20210423152918083.png)

- PSTATE at AArch32

在 AArch64 中，传统的 CPSR 寄存器被 PSTATE 取代。

![image-20210423153622163](figures/image-20210423153622163.png)

### NEON 与浮点寄存器

除了通用寄存器组之外， ARMv8 也提供了 32 个 128 位的浮点寄存器组，V0-V31。这 32 个寄存器用户保存浮点操作数用于标量浮点执行或者标量和向量操作数用于 NEON 操作。

#### 标量寄存器大小

![image-20210423154416039](figures/image-20210423154416039.png)

#### 向量寄存器大小

![image-20210423154455999](figures/image-20210423154455999.png)

针对不同大小的向量操作：

![image-20210423154551451](figures/image-20210423154551451.png)

#### NEON 在 AArch32 运行模式下

在 AArch32 中，小的寄存器被打包成更大的寄存器，例如 D0 和 D1 被组合成 Q1。这就引入了一些复杂的循环依赖关系，会降低编译器向量化循环结构的能力。

![image-20210423155325041](figures/image-20210423155325041.png)

## ARMv8 指令集

ARMv8 架构最大的变化之一就是引入了额外的 64 位指令集，补充了现有的 32 位指令集架构。这一添加提供了访问 64 位宽的整数寄存器和数据操作，以及使用 64 位大小的指针访问内存的能力。新的指令集称为 A64，运行在 AArch64 执行状态。ARMv8 也包括先前的 ARM 指令集，现在叫做 A32 和 T32 指令集，这两种指令集都运行在 AArch32 状态，提供对 ARMv7 的先后兼容。

另外有一点需要注意的是，A64 指令集的操作码的长度仍然是 32 位，而不是 64 位。

### A64 指令集

A64 的指令助记符与 ARMv7 没有太大变化，只是所操作的寄存器形式不同， AArch64 寄存器有不同的位宽，但是我们并不需要记住不同形式的指令，汇编器会根据我们操作的寄存器名称自动选择合适的编码。

## 内存管理单元

MMU 的一个重要功能是使得系统可以运行多任务，作为一个独立的程序运行在它的私有虚拟地址空间上。

## 安全系统

