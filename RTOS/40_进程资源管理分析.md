# 进程资源管理分析

在 smart 操作系统中，进程是资源分配的实体，进程需要管理的资源如下所示：

- 用户进程 ID
- 用户线程 ID
- 内核对象的管理（包括 IPC 以及定时器等，进程退出时需要释放）
- 内存管理
- 用户线程本地存储（TLS）

下面分别就这些资源类型进行详细说明。

## 用户进程 ID （PID）

系统中可能存在多核用户进程，smart 操作系统使用 PID 作为进程的唯一标识符。当创建进程时，需要申请分配一个 PID 与之对应。当用户进程终止时，该 PID 会被回收。

存储 PID 的数据结构是一个数组和一个单链表：

```c
static struct lwp_avl_struct lwp_pid_ary[RT_LWP_MAX_NR];

/* the head node of single linked list to store free pid */

static struct lwp_avl_struct *lwp_pid_free_head = RT_NULL;
```

### 申请 PID

获取 lwp 的函数为 `lwp_pid_get`，其功能如下：

1. 尝试在空闲链表中获取可用 PID
2. 如果空闲链表中没有可用 PID 则尝试从 `lwp_pid_ary` 数组中获得 PID
3. 从数组中获取 PID 的情况下，将尝试获取比当前 PID 数值更大的 PID 号
4. 如果无法获取数值更大的 PID，则尝试从 1 开始遍历数组，获取一个较小的 PID 号码
5. 成功获取 PID 后，将其插入存储已用 pid 的二叉树 `lwp_pid_root`
6. 返回 PID

```c
/**
 * This function will allocate and return a unique lwp ID.
 *
 * @return a unique lwp ID on success, 0 on failure
 */
static pid_t lwp_pid_get(void)
{
    rt_base_t level = 0;
    struct lwp_avl_struct *p = RT_NULL;
    pid_t pid = 0;
    int found = 0;

    level = rt_hw_interrupt_disable();

    /* backup the pid free head */
    p = lwp_pid_free_head;

    /* check if there is a node available in the free list */
    if (p)
    {
        /* have a lwp node in free list, then remove it */
        lwp_pid_free_head = (struct lwp_avl_struct *)p->avl_right;
    }
    else
    {
        /* no free lwp node in free list, get a free node from pid array */
        if (lwp_pid_ary_alloced < RT_LWP_MAX_NR)
        {
            p = lwp_pid_ary + lwp_pid_ary_alloced;
            lwp_pid_ary_alloced++;
        }
    }

    if (p)
    {
        RT_ASSERT(p->data == RT_NULL);

        /* try to get a pid bigger than the current pid */
        for (pid = current_pid + 1; pid < PID_MAX; pid++)
        {
            /* check if the pid is no used */
            if (!lwp_avl_find(pid, lwp_pid_root))
            {
                found = 1;
                break;
            }
        }

        /* try to get a pid number from 1 to the current pid */
        if (!found)
        {
            for (pid = 1; pid <= current_pid; pid++)
            {
                if (!lwp_avl_find(pid, lwp_pid_root))
                {
                    found = 1;
                    break;
                }
            }
        }

        if(found)
        {
            /* find a free pid node */
            p->avl_key = pid;
            lwp_avl_insert(p, &lwp_pid_root);
            current_pid = pid;
        }
        else
        {
            /* can't find a free node */
            pid = 0;
        }
    }
    rt_hw_interrupt_enable(level);

    return pid;
}
```

### 释放 PID

释放 PID 的函数 `lwp_pid_put` 就比较简单了，其功能如下：

1. 在 `lwp_pid_root` 二叉树中查找到相应的 PID 节点
2. 将该节点从 `lwp_pid_root` 二叉树中移除
3. 将该节点插入到空闲 PID 链表中，便于后续快速获得 PID 

代码实现如下所示：

```c
/**
 * This function will release the unique lwp ID.
 *
 * @param tid the unique lwp ID to be released
 */
static void lwp_pid_put(pid_t pid)
{
    rt_base_t level = 0;
    struct lwp_avl_struct *p = RT_NULL;

    level = rt_hw_interrupt_disable();
    p  = lwp_avl_find(pid, lwp_pid_root);
    if (p)
    {
        p->data = RT_NULL;
        lwp_avl_remove(p, &lwp_pid_root);
        p->avl_right = lwp_pid_free_head;
        lwp_pid_free_head = p;
    }
    rt_hw_interrupt_enable(level);
}
```

## 用户线程 ID（TID）

每个用户进程中可能包含 1 到多个用户线程，每个用户线程都有其唯一的标识编号，即用户线程 ID。当创建用户线程时，需分配一个用户线程 ID 与之对应。当终止用户线程时，需要释放并回收该线程 ID。

用户线程 ID 的申请和释放过程与用户进程 ID 的操作方法是一致的，用了同样的数据结构以及同样的操作算法，只不过他们分别管理的资源是完全独立的，这里就不再详细说明。

## 内核对象管理

用户进程可以通过系统调用申请使用内核对象，可能申请的对象包括各种 IPC、定时器等等。进程主动退出或者意外退出时，需要查找进程使用的内核对象，并释放和回收这些资源。

在 lwp 结构中使用 `struct lwp_avl_struct *object_root;`  对象管理二叉树来存储进程所使用的过的内核对象。

在进程使用系统调用创建内核对象时，会先将该对象插入到进程的对象管理树中。