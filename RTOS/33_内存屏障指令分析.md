# 内存屏障指令分析

## 内存屏障产生的原因

若程序在执行时的实际内存访问顺序和程序代码编写的访问顺序不一致，会导致内存乱序访问。内存访问的出现是为了提高程序执行时的效率。内存乱序访问主要发生在如下两个阶段：

1. 编译时，编译器优化导致内存乱序访问。
2. 执行时，多个 CPU 间交互引起的内存乱序访问。

### 编译器优化

编译器会把符合人类思维逻辑的代码翻译成符合 CPU 运算规则的汇编指令，编译器了解底层 CPU 的思维，因此它会在翻译汇编指令时对其进行优化。如内存访问指令的重新排序可以提高指令级并行效率。然而，这些优化可能会与程序员原始的代码逻辑不符，导致一些错误发生。编译时的乱序可以通过 barrier() 函数来规避。

```c
#define barrier() __asm__ __volatile__ ("" ::: "memory")
```

`barrier()` 函数告诉编译器，不要为了性能优化而将这些代码重排。

### 处理器优化

由于现代处理器普遍采用超标量架构、乱序发射以及乱序执行等技术来提高指令级并行效率，因此指令的执行序列在处理器流水线中可能被打乱，与程序代码编写时序列不一致。另外现代处理器采用多级存储结构，如何保证处理器对存储子系统访问的正确性也是一大挑战。

## 弱一致性内存模型

ARM 采用弱一致性内存模型。在一个多处理器系统中，满足如下 3 个条件的内存访问称为弱一致性的内存访问。

- 所有处理器对全局同步变量的访问是顺序一致的
- 在之前的全局数据（global data）访问完成之前，任何处理器不能访问全局同步变量
- 在全局同步变量释放之前，任何处理器不能访问全局数据

弱一致性内存模型要求同步访问（访问全局同步变量）是顺序一致的，在一个同步访问可以执行之前，先前的所有数据访问必须完成。在一个正常的数据访问可以执行之前，所有之前的同步访问必须完成。这就相当于把一致性问题留给了程序员来解决。在 ARM 处理器中使用内存屏障指令的方式来实现同步访问。内存屏障指令的基本原则如下：

- 所有在内存屏障指令之前的数据访问必须在内存屏障指令之前完成
- 所有在内存屏障指令后面的数据访问必须等待内存屏障指令执行完
- 多条内存屏障指令是按顺序执行的

## ARM 处理器的内存屏障

处理器会根据内存屏障的作用范围进行细分，例如 ARM64 处理器把内存屏障指令细分为数据存储屏障指令、数据同步屏障指令以及指令同步屏障指令。

