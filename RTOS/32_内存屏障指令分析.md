# 内存屏障指令分析

## 内存屏障产生的原因

若程序在执行时的实际内存访问顺序和程序代码编写的访问顺序不一致，会导致**内存乱序访问**。内存访问的出现是为了提高程序执行时的效率。内存乱序访问主要发生在如下两个阶段：

1. 编译时，编译器优化导致内存乱序访问。
2. 执行时，多个 CPU 间交互引起的内存乱序访问。

### 编译器优化

编译器会把符合人类思维逻辑的代码翻译成符合 CPU 运算规则的汇编指令，编译器了解底层 CPU 的思维，因此它会在翻译汇编指令时对其进行优化。如内存访问指令的重新排序可以提高指令级并行效率。然而，这些优化可能会与程序员原始的代码逻辑不符，导致一些错误发生。编译时的乱序可以通过 barrier() 函数来规避。

```c
#define barrier() __asm__ __volatile__ ("" ::: "memory")
```

`barrier()` 函数告诉编译器，不要为了性能优化而将这些代码重排。

### 处理器优化

由于现代处理器普遍采用超标量架构、乱序发射以及乱序执行等技术来提高指令级并行效率，因此指令的执行序列在处理器流水线中可能被打乱，与程序代码编写时序列不一致。另外现代处理器采用多级存储结构，如何保证处理器对存储子系统访问的正确性也是一大挑战。

## 弱一致性内存模型

ARM 采用弱一致性内存模型。在一个多处理器系统中，满足如下 3 个条件的内存访问称为弱一致性的内存访问。

- 所有处理器对全局同步变量的访问是顺序一致的
- 在之前的全局数据（global data）访问完成之前，任何处理器不能访问全局同步变量
- 在全局同步变量释放之前，任何处理器不能访问全局数据

弱一致性内存模型要求同步访问（访问全局同步变量）是顺序一致的，在一个同步访问可以执行之前，先前的所有数据访问必须完成。在一个正常的数据访问可以执行之前，所有之前的同步访问必须完成。这就相当于把一致性问题留给了程序员来解决。在 ARM 处理器中使用内存屏障指令的方式来实现同步访问。内存屏障指令的基本原则如下：

- 所有在内存屏障指令之前的数据访问必须在内存屏障指令之前完成
- 所有在内存屏障指令后面的数据访问必须等待内存屏障指令执行完
- 多条内存屏障指令是按顺序执行的

##  ARMv8 内存屏障指令

ARMv8 架构实现了弱一致性内存模型，内存访问的次序有可能和程序预期的次序不一样。A64 和 A32 指令集提供了内存屏障指令，ARM64 处理器把内存屏障指令细分为数据存储屏障指令、数据同步屏障指令以及指令同步屏障指令。如下表所示：

| 指令 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| DMB  | 数据存储屏障（Data Memory Barrier, DMB），用于确保在执行新的存储器访问前，所有的存储器访问都已经完成 |
| DSB  | 数据同步屏障（Data Synchronization Barrier, DSB），用于确保在下一个指令执行前，所有的存储器访问都已经完成 |
| ISB  | 指令同步屏障（Instruction Synchronization Barrier，ISB），用于清空流水线，确保在执行新的指令前，之前所有的指令都已经完成 |

## 内存屏障指令示例

### 示例一

假设有两个 CPU 内核 A 和 B，同时访问 Addr1 和 Addr2。

```asm
CORE A:
    STR R0, [Addr1]
    LDR R1, [Addr2]
    
CORE B:
    STR R2, [Addr2]
    LDR R3, [Addr1]
```

在上面的代码片段中，没有任何同步措施，因此会受到处理器乱序执行的影响，导致最终执行的结果不确定，也就是说这四条指令的执行顺序是不确定的。对于 Core A 的寄存器 R1、Core B 的寄存器 R3，可能得到如下四种不同的结果：

- 处理器 A 与处理器 B 都得到旧值
- 处理器 A 得到旧值，处理器 B 得到新值
- 处理器 A 的到新值，处理器 B 得到旧值
- 处理器 A 与处理器  B 都得到新值

### 示例二

假设处理器 A 把数据写入 MSG 地址，处理器 B 需要判断 flag 的位置后才读取新数据。

```asm
Core A:
    STR R0, [msg]       @ 写新的数据到 msg 地址
    STR R1, [flag]      @ 写新的数据到 flag 地址

Core B:
    Poll_loop:
        LDR R1, [flag]
        CMP R1, #0      @ 判断 flag 是否置位
        BEQ Poll_loop
        LDR R0, [msg]   @ 读取新数据
```

在上面的代码片段中，CORE B 可能读不到最新的数据， Core B 可能由于乱序执行的原因先读取 msg 然后才读取 flag。在弱一致性模型中，处理器不知道 msg 与 flag 之间存在数据依赖关系，所以程序员必须使用内存屏障指令来显示的告诉处理器这两个变量有数据依赖关系。CORE A 需要在两个存储指令之间插入 DMB 指令来保证两个存储指令的执行顺序。CORE B 需要在 `LDR R0, [msg]` 之前插入 DMB 指令来保证直到 flag 被置位以后才读取 msg，修改后的代码如下：

```asm
Core A:
    STR R0, [msg]       @ 写新的数据到 msg 地址
    DMB
    STR R1, [flag]      @ 写新的数据到 flag 地址

Core B:
    Poll_loop:
        LDR R1, [flag]
        CMP R1, #0      @ 判断 flag 是否置位
        BEQ Poll_loop
        DMB
        LDR R0, [msg]   @ 读取新数据
```

### 示例三

在一个设备驱动中，写一个命令到外设寄存器中，然后等待状态的变化。使用 DSB 指令可以确保写入外设寄存器命令一定是在读取状态寄存器操作之前完成。

```asm
STR R0, [Addr]          @ 写入命令到外设寄存器
DSB
Poll_loop:
    LDR R1, [flag]      @ 等待状态寄存器的变化
    CMP R1, #0
    BEQ Poll_loop
```

